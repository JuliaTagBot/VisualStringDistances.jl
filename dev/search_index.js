var documenterSearchIndex = {"docs":
[{"location":"visualizations/#Visualizations","page":"Visualizations","title":"Visualizations","text":"","category":"section"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The script scripts/anim/plotting.jl can be used to generate pictures showing the transport from one string to another.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"First, we can use a balanced optimal transport to visualize the difference between \"hello\" (spelled the usual way), and \"heIIo\" (with uppercase eye's instead of lowercase ell's).","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"using VisualStringDistances\nusing UnbalancedOptimalTransport: KL, Balanced\n\ninclude(joinpath(@__DIR__, \"..\", \"plotting.jl\"))\nanimate_words(\"hello\", \"heIIo\"; D = Balanced(), normalize_density=true, save_path=\"hello_heIIo_balanced.gif\")","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"(Image: )","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"We see that mass has to move from all the letters in order to create part of the I's. In contrast, let us try an unbalanced method that instead allows creation or destruction of mass with a penalty.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"animate_words(\"hello\", \"heIIo\"; D = KL(1.0), save_path=\"hello_heIIo.gif\")","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"(Image: )","category":"page"},{"location":"packagenames/#Package-names","page":"Package names","title":"Package names","text":"","category":"section"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"One of the motivations for this package was to investigate using visual distances to look out for issues similar to typosquatting in the Julia General package registry.","category":"page"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"The problem of interest is the following: say a user is following a Julia tutorial online, but a malicious person has substituted a popular package name for a similiar-looking one in the tutorial. When the unsuspecting user copy-pastes the commands to install the package, they don't realize they are installing the malicious one. To prevent this kind of abuse, it could be useful to add an automated check to the registry process to check that new package registrations' names aren't very close visually to existing packages, and to perhaps issue a warning when they are.","category":"page"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"visual_distance provides a means of evaluating how close two strings look. Let's investigate it in the context of package names.","category":"page"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"Let us consider some visually-confusable names, and compute their visual distances, as well as a simple edit distance (the Damerau-Levenshtein distance).","category":"page"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"using VisualStringDistances, DataFrames, StringDistances\nconst DL = DamerauLevenshtein();\n\n# Define our distance measure\nd(s1, s2) = visual_distance(s1, s2; normalize=x -> 5 + sqrt(x))\nd((s1,s2)) = d(s1, s2)\n\ndf_subs = DataFrame([\n    (\"jellyfish\", \"jeIlyfish\"), # https://developer-tech.com/news/2019/dec/05/python-libraries-dateutil-jellyfish-stealing-ssh-gpg-keys/\n    (\"DifferentialEquations\", \"DifferentIalEquations\"),\n    (\"ANOVA\", \"AN0VA\"),\n    (\"ODEInterfaceDiffEq\", \"0DEInterfaceDiffEq\"),\n    (\"ValueOrientedRiskManagementInsurance\", \"ValueOrientedRiskManagementlnsurance\"),\n    (\"IsoPkg\", \"lsoPkg\"),\n    (\"DiffEqNoiseProcess\", \"DiffEgNoiseProcess\"),\n    (\"Graph500\", \"Graph5O0\")\n]);\nrename!(df_subs, [:name1, :name2]);\ndf_subs.DL = DL.(df_subs.name1, df_subs.name2);\ndf_subs.sqrt_normalized_DL = df_subs.DL ./ ( 5 .+ sqrt.(max.(length.(df_subs.name1), length.(df_subs.name2))) );\ndf_subs.sqrt_normalized_visual_dist = d.(df_subs.name1, df_subs.name2);\nsort!(df_subs, :sqrt_normalized_visual_dist);","category":"page"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"df_subs","category":"page"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"We can see all the pairs have DL distance of 1, since they are 1 edit apart. Their normalized DL-distances thus just depend on their length. However, they have various visual distances, depending on what subsitution was made. Note that GNU Unifont renders zeros with a slash through the middle, and hence VisualStringDistances.jl sees \"O\" and \"0\" as fairly different.","category":"page"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"Let us compare to some real package names from the registry. We will in fact consider all package names, but then filter them down to a manageable list via the edit distance.","category":"page"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"using Pkg\n\nfunction get_all_package_names(registry_dir::AbstractString)\n    packages = [x[\"name\"] for x in values(Pkg.TOML.parsefile(joinpath(registry_dir, \"Registry.toml\"))[\"packages\"])]\n    sort!(packages)\n    unique!(packages)\n    return packages\nend\n\nnames = get_all_package_names(expanduser(\"~/.julia/registries/General\"));\n\nfilter!(x -> !endswith(x, \"_jll\"), names);\n@info \"Loaded list of non-JLL package names ($(length(names)) names)\"\n\nnormalized_dl_cutoff = .2;\ndl_cutoff = 1;\n@info \"Computing list of pairs of package names within $(dl_cutoff) in DL distance or $(normalized_dl_cutoff) in normalized DL distance...\"\n@time df = DataFrame(collect( (name1=names[i],name2=names[j]) for i = 1:length(names) for j = 1:(i-1) if (normalize(DL)(names[i], names[j]) <= normalized_dl_cutoff) || DL(names[i], names[j]) <= dl_cutoff));\n\n@info \"Found $(size(df,1)) pairs of packages meeting the criteria.\";\n\ndf.DL = DL.(df.name1, df.name2);\ndf.sqrt_normalized_DL = df.DL ./ ( 5 .+ sqrt.(max.(length.(df.name1), length.(df.name2))) );\n\n@info \"Computing visual distance...\";\n@time df.sqrt_normalized_visual_dist = d.(df.name1, df.name2);","category":"page"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"Let's look at the 5 closest pairs according to the normalized visual distance.","category":"page"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"sort!(df, :sqrt_normalized_visual_dist);\ndf[1:5, :]","category":"page"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"Here, we see that by this measurement, the closest pair of packages is \"Modia\" and \"Media\". Indeed they look fairly similar, although they are not as easy to mistake for each other as many of the earlier examples.","category":"page"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"Let's compare to the 5 closest pairs according to the normalized edit distance.","category":"page"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"sort!(df, :sqrt_normalized_DL);\ndf[1:5, :]","category":"page"},{"location":"packagenames/","page":"Package names","title":"Package names","text":"These are just the longest package names that are 1 edit away from each other.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = VisualStringDistances","category":"page"},{"location":"#VisualStringDistances","page":"Home","title":"VisualStringDistances","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [VisualStringDistances]","category":"page"},{"location":"#VisualStringDistances.Glyph","page":"Home","title":"VisualStringDistances.Glyph","text":"Glyph <: AbstractArray{Bool,2}\n\nHolds the bitmap associated to a Unifont glyph in a packed format.\n\n\n\n\n\n","category":"type"},{"location":"#VisualStringDistances.Glyph-Tuple{AbstractString}","page":"Home","title":"VisualStringDistances.Glyph","text":"Glyph(s::AbstractString) --> Glyph\n\nConstruct a Glyph from a string.\n\nExamples\n\njulia> Glyph(\"abc\")\n------------------------\n------------------------\n------------------------\n---------#--------------\n---------#--------------\n---------#--------------\n--####---#-###----####--\n-#----#--##---#--#----#-\n------#--#----#--#------\n--#####--#----#--#------\n-#----#--#----#--#------\n-#----#--#----#--#------\n-#---##--##---#--#----#-\n--###-#--#-###----####--\n------------------------\n------------------------\n\n\n\n\n\n","category":"method"},{"location":"#VisualStringDistances.GlyphCoordinates","page":"Home","title":"VisualStringDistances.GlyphCoordinates","text":"GlyphCoordinates{T} <: AbstractVector{T}\n\nA sparse representation of a Glyph.\n\n\n\n\n\n","category":"type"},{"location":"#VisualStringDistances.glyph!-Tuple{Array{UInt8,1}}","page":"Home","title":"VisualStringDistances.glyph!","text":"glyph!(v::Vector{UInt8}) -> Glyph\n\nCreates a Glyph for a vector of bytes, assuming the vector represents a single Unifont character. Modifies v and may share its memory.\n\n\n\n\n\n","category":"method"},{"location":"#VisualStringDistances.printglyph","page":"Home","title":"VisualStringDistances.printglyph","text":"printglyph([io=stdout], g::Union{Char, AbstractString, Glyph})\n\nPrints a visual representation of g to io.\n\n\n\n\n\n","category":"function"},{"location":"#VisualStringDistances.visual_distance-Union{Tuple{T}, Tuple{Type{T},Union{Char, AbstractString},Union{Char, AbstractString}}} where T","page":"Home","title":"VisualStringDistances.visual_distance","text":"visual_distance(::Type{T}, s::Union{Char,AbstractString},\n                     t::Union{Char,AbstractString}; D=KL(one(T)), ϵ=T(0.1),\n                     normalize=nothing) where {T}\n\nComputes a measure of distance between the strings s and t in terms of their visual representation as rendered by GNU Unifont and quantified by an unbalanced Sinkhorn divergence from UnbalancedOptimalTransport.jl.\n\nThe keyword argument D chooses the UnbalancedOptimalTransport.AbstractDivergence used to penalize the creation or destruction of \"mass\" (black pixels). For D = VisualStringDistances.KL(ρ) for some number ρ ≥ 0, the distance is non-negative and zero if and only if the two visual representations of the strings are the same, as is generally desired.\nThe keyword argument ϵ sets the \"entropic regularization\" in the Sinkhorn divergence; see the documentation there for more information. In short, smaller ϵ computes a quantity more directly related to the cost of moving mass, but takes longer to compute.\nThe keyword argument normalize can be chosen to be a function which returns a normalizing constant given the maximum length of the two strings. The choice normalize=identity thus divides the result by the maximum length of the two strings. The choice normalize=sqrt has been found to give a good balance in some settings.\n\nOne may use printglyph to see the visual representation of the strings as rendered by GNU Unifont.\n\nnote: Note\nAt the time of this writing, GNU Unifont is capable of rendering 57086 different unicode characters. However, it renders some unicode characters with the same graphical representation; specifically, 689 distinct unicode characters have duplicate representations. Here's a set of six duplicates, for example: 'Ꮋ': Unicode U+13BB (category Lu: Letter, uppercase)\n'Н': Unicode U+041D (category Lu: Letter, uppercase)\n'ꓧ': Unicode U+A4E7 (category Lo: Letter, other)\n'Ⲏ': Unicode U+2C8E (category Lu: Letter, uppercase)\n'Η': Unicode U+0397 (category Lu: Letter, uppercase)\n'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)The visual distance between these, therefore, is returned as zero (up to numerical error).\n\nExample\n\njulia> using VisualStringDistances\n\njulia> printglyph(\"abc\")\n------------------------\n------------------------\n------------------------\n---------#--------------\n---------#--------------\n---------#--------------\n--####---#-###----####--\n-#----#--##---#--#----#-\n------#--#----#--#------\n--#####--#----#--#------\n-#----#--#----#--#------\n-#----#--#----#--#------\n-#---##--##---#--#----#-\n--###-#--#-###----####--\n------------------------\n------------------------\n\njulia> printglyph(\"def\")\n------------------------\n------------------------\n------------------------\n------#-------------##--\n------#------------#----\n------#------------#----\n--###-#---####-----#----\n-#---##--#----#--#####--\n-#----#--#----#----#----\n-#----#--######----#----\n-#----#--#---------#----\n-#----#--#---------#----\n-#---##--#----#----#----\n--###-#---####-----#----\n------------------------\n------------------------\n\njulia> visual_distance(\"abc\", \"def\")\n31.57060117541754\n\njulia> visual_distance(\"abc\", \"abe\")\n4.979840716647487\n\n\n\n\n\n","category":"method"}]
}
